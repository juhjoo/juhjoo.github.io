---
title: 이진 탐색 트리(Binary Search Tree)
categories: 
  - Data Structure & Algorithms
last_modified_at: 2020-04-07T13:00:00+09:00
use_math: true
---

이진 탐색 트리는 이진 탐색(binary search)과 연결리스트(linked list)를 결합한 자료구조 입니다. 이진 탐색에서 탐색이 시간복잡도 $O(\log{n})$으로 빠르지만 삽입, 삭제가 불가능하고, 연결 리스트의 경우 자료 입력, 삭제에 시간복잡도가 $O(1)$로 효율적이지만 탐색하는데는 $O(n)$의 시간복잡도가 발생합니다. 이 두가지를 합친 것이 바로 이진 탐색 트리라고 보시면 됩니다. 이진탐색트리의 시각화를 보실려면 <a href="https://visualgo.net/bn/bst?slide=1">https://visualgo.net/bn/bst?slide=1</a>로 가시면 됩니다.


![ex_screenshot](https://i.imgur.com/mDq4RGo.png)


## 이진 탐색 트리 특징  

이진탐색트리는 다음과 같은 속성을 지니고 있습니다.  


1. 노드의 왼쪽에 위치한 서브트리는 해당 노드의 값보다 작은 값을 지닌다.
2. 노드의 오른쪽에 위치한 서브트리는 해당 노드의 값보다 큰 값을 지닌다.
3. 중복된 노드가 없어야 하며, 왼쪽/오른쪽 서브트리 또한 이진 탐색 트리다.


이진탐색트리는 순회할 때 왼쪽 서브트리 - 노드 - 오른쪽 서브트리 순서로 중위순회 방식(inorder method)을 사용합니다. 이렇게 하면 모든 값들을 정렬된 순서대로 읽을 수 있기 때문입니다.  


![ex_screenshot](https://i.imgur.com/xMpPqpS.png)


이진탐색트리의 핵심 연산은 탐색, 삽입, 삭제입니다. 가장 먼저 탐색에 대해서 살펴보겠습니다.  


### 탐색(search)  

이진탐색트리의 속성인 부모노드가 왼쪽보다 크고 오른쪽 노드보다는 작다는 점을 활용하면 효율적인 탐색이 가능합니다.  


![ex_screenshot](https://i.imgur.com/HigWQGN.png)


위 그림인 이진탐색트리에서 10을 탐색하는 과정에 대해서 살펴보겠습니다. 먼저 루트노드 7보다 10이 크기 때문에 왼쪽 서브트리(1, 3, 5)는 고려하지 않습니다. 바로 오른쪽 서브트리의 루트노드(8)로 가서 10과 비교하고 10이 8보다 크기 때문에 마찬가지로 노드 8의 왼쪽 서브트리는 고려하지 않고 바로 오른쪽 노드의 10을 비교하여 원하는 값을 찾습니다.  


탐색 과정을 아래와 같은 의사코드로 표현할 수 있습니다.  


```java
Tree-Search(x, L)
  if x == NIL or k == x.key
    return x
  if k < x.key
     return Tree-Search(x.left, k)
  else return Tree-Search(x.right, k)
```


이진탐색트리의 탐색에 소요되는 시간복잡도는 트리의 높이가 h일 때 $O(h)$가 됩니다. 그 이유는 최악의 경우 가장 마지막 노드(잎새노드라고 합니다)까지 탐색해야 하기 때문입니다.  


### 삽입(insert)  

이번에는 삽입 연산을 살펴보도록 하겠습니다. 새로운 데이터는 트리의 잎새노드 즉 마지막 노드에 삽입됩니다. 아래 트리에서 13을 루트노즈 12와 18사이에 추가해도 이진탐색트리 속성이 깨지지 않고 15의 왼쪽노드에 삽입 되는 것을 볼 수 있습니다. 새 데이터를 삽입하게 되면 서브트리의 속성이 깨지기 때문에 삽입은 무조건 잎새노드에 이루어지게 됩니다.  


![ex_screenshot](https://i.imgur.com/ULG5AJn.png)


이진탐색트리 삽입에 소요되는 시간복잡도 역시 트리의 높이가 h 일때 $O(h)$가 됩니다. 삽입할 위치의 잎새노드를 찾아가는데 h번 비교하여아 하기 때문입니다. 여기서 탐색 연산도 추가되기는 하지만 이것은 무시할 만한 수준이 $O(1)$ 입니다.  


삽입 과정을 아래와 같은 의사코드로 표현할 수 있습니다.  


```java
Tree-Insert(T, z)
  y = NIL
  x = T.root
  while x != NIL
    y = x
    if z.key < x.key
      x = x.left
    else x = x.right
 z.p = y
 if y == NIL
   T.root = z
 elseif z.key < y.key
   y.left = z
 else y.right =z
```


### 삭제(delete)  

이진탐색트리에서 가장 복잡한 부분은 바로 삭제라고 볼 수 있습니다. 삭제를 통해 이진탐색트리의 속성이 깨질 수 있기 때문입니다. 삭제는 세가지 케이스를 살펴봐야 합니다. 1) 삭제할 노드에 자식 노드가 없는 경우, 2) 삭제할 노드에 자식노드가 하나 있는 경우, 3) 삭제할 노드에 자식노드가 두개 있는 경우입니다.  

##### 1) 삭제할 노드에 자식 노드가 없는 경우  


이 경우에는 삭제할 노드 42를 그냥 없애기만 하면 됩니다. 자식 노드가 없기 때문에 이진탐색트리의 속성에 영향을 주기 않습니다.  


![ex_screenshot](https://i.imgur.com/w6N9hGq.png)


##### 2) 삭제할 노드에 자식 노드가 하나 있는 경우  


이 경우는 해당 노드를 지우고 그 노드의 자식노드와 부모노드를 연결해 주면 됩니다. 아래 그림에서 20을 삭제한다고 할 경우 20의 자식노드인 25와 부모노드인 30을 연결해주기만 하면 이진트리의 속성이 깨지지 않고 삭제되는 것을 볼 수 있습니다.  


![ex_screenshot](https://i.imgur.com/aREKH8O.png)


##### 2) 삭제할 노드에 자식 노드가 두개 있는 경우  


마지막으로 자식 노드가 두개 있는 경우는 다른 두가지 경우에 비해 더 복잡합니다. 아래 트리에서 16을 삭제할 경우 루트노드인 10과 연결할 노드가 애매해지기 때문입니다.  


![ex_screenshot](https://i.imgur.com/xAH8dHm.png)


이를 해결하기 위해 이 것을 중위순회 방식으로 아래와 같이 표현해 보겠습니다. 여기서 삭제하고자하는 16의 이전 값은 13이고 그 다음 값은 20입니다. 여기서 13을 predecessor(삭제 노드의 왼쪽 서브트리 가운데 최대값)이라고하고 20을 successor(삭제 노드의 오른쪽 트리 가운데 최소값)라고 합니다.  

```
4, 10, 13, 16, 20, 22, 25, 28, 30, 32
```


따라서 삭제할 노드인 16 위치에 바로 뒷 값이 20(successor, 삭제 노드의 오른쪽 트리 가운데 최소값)을 복사해 놓고 기존 20이 있는 노드를 삭제한 후 20의 부모노드와 자식노드를 연결하면 이진트리 속성을 깨지 않으면서 삭제를 할 수 있습니다. 여기서 알아두실 점은 이진트리 구조상 successor은 자식노드가 하나이거나, 하나도 존재하지 않습니다.  


![ex_screenshot](https://i.imgur.com/YgvjBS5.png)


삭제의 시간복잡도를 살펴보면 트리의 높이가 h이고 삭제대상 노드의 레벨이 d라고 할때, 삭제 대상 노드의 오른쪽 서브트리를 찾는 과정에서 d번의 비교 연산이 필요합니다. 그 다음 successor 노드를 찾기 위해서는 삭제 대상 노드의 서브트리 높이 (h-d)에 해당하는 비교 연산을 수행합니다. 마지막으로 successor 노드이 값을 복사한 다음 삭제하는 연산은 상수시간이 걸리기 때문에 무시 할 수 있습니다.   
이를 계산하면 $O(ㅇ+h-d)$, 즉 $O(h)$가 됩니다.  


| 구  분         | 시간복잡도        | 
|----------------|-----------------|
|       삽입(Insertion)         |      $O(1)$          |  
|       탐색(Search)         |      $O(h)$          |   
|       삭제(Delete)         |      $O(h)$          |   

