---
title: 퀵 정렬(Quick Sort) 알고리즘
categories: 
  - Data Structure & Algorithms
last_modified_at: 2020-04-08T13:00:00+09:00
use_math: true
---

퀵 정렬(Quick Sort) 알고리즘에 대해서 살펴보도록 하겠습니다. 퀵 정렬은 기본적으로 분할정복(divide and conquer) 방식입니다. 이 절차는 리스트 가운데 하나를 선택합니다. 이것을 피봇(pivot)이라 합니다. 그 다음 피벗 앞에는 피벗보다 작은 값, 뒤에는 큰 값이 오도록 하여 리스트를 분할합니다. 이 분할된 두 개의 리스트 각각에 재귀적으로 이 과정을 반복합니다.

## 퀵 정렬 예시

퀵 정렬이 어떻게 이루어지는지 예시를 살펴보도록 하겠습니다. 먼저 아래 표에서 (5, 3, 7, 8, 2, 1, 4)를 퀵 정렬을 이용한 예시를 살펴보겠습니다. 아래 표에서 피벗은 p, 리스트 왼쪽 끝 값은 j, i는 j-1 로 합니다.

|  5     |     3   |   7    |    8   |   2    |   1    |   4    |
|------ |------ |------ |------ |------ |------ |------ |
|    j   |        |       |       |       |       |  p     |


먼저 j와 피벗을 비교하여 크면 j에 1을 더해주어 다음으로 넘어갑니다.


 |  5     |     3   |   7    |    8   |   2    |   1    |   4    |
|------ |------ |------ |------ |------ |------ |------ |------ |
|   j   |        |       |       |       |       |  p     |


j와 피벗을 비교하면 j가 작기 때문에 i에 1을 더하여 첫번째로 온 후 i값 5와 j값 3을 변경하여 줍니다.


 |  5     |     3  |   7    |    8   |   2    |   1    |   4    |
|------ |------ |------ |------ |------ |------ |------ |------ |
|   i   |    j    |       |       |       |       |  p     |


j와 피벗을 비교하면 j가 크기 때문에 j에 1을 더해주며 다음으로 넘어갑니다.

 |  3     |     5   |   7    |    8   |   2    |   1    |   4    |
|------ |------ |------ |------ |------ |------ |------ |------ |
|   i   |        |  j     |       |       |       |  p     |


마찬가지로 j가 7일 때도 피벗보다 크기 때문에 교환하지 않습니다.


 |  3     |     5   |   7    |    8   |   2    |   1    |   4    |
|------ |------ |------ |------ |------ |------ |------ |------ |
|   i   |        |       |   j    |       |       |  p     |



j가 2로 피벗보다 작기 때문에 i를 1 더해준 5와 교환합니다.


 |  3     |     5   |   7    |    8   |   2    |   1    |   4    |
|------ |------ |------ |------ |------ |------ |------ |------ |
|      |    i    |       |       |   j    |       |  p     |


그 다음 j가 1로 피벗보다 마찬가지로 작기 때문에 i를 1더해준 7과 교환합니다.


 |  3     |     2   |   7    |    8   |   5    |   1    |   4    |
|------ |------ |------ |------ |------ |------ |------ |------ |
|      |        |    i   |       |       |  j     |  p     |



이제 마지막으로 i에 1을 더한 8과 피벗인 4를 교환해주면 4를 기준으로 왼쪽은 4보다 작은 값(3, 2, 1), 오른쪽은 4보다 큰 값(5, 7, 8)로 정렬된 것을 볼 수 있습니다.


 |  3     |     2   |   1    |    4   |   5    |   7    |   8    |
|------ |------ |------ |------ |------ |------ |------ |------ |
|      |        |       |   i    |       |  j     |  p     |


이와 같은 순서로 다시 4를 기준으로 왼쪽과 오른쪽 리스트를 재귀적으로 반복 수행하여 최종적으로 (1, 2, 3, 4, 5, 7, 8)과 같이 정렬할 수 있습니다.


## 퀵 정렬 의사코드

이번에는 위에서 진행한 퀵 정렬 알고리즘을 의사코드로 알아보도록 하겠습니다

```
Quicksort(a, left, right) 
  if left < right
    pivot = Partition(a, left, right)
    Quicksort(a, left, pivot - 1)
    Quicksort(a, pivot + 1, right)
    

Partition(a, left, pivot)
  pivotvalue = a[pivot]
  i = left - 1
  
  for j = left to pivotvalue
    if a[j] < pivot
      i = i + 1
      exchange a[j] with a[i]
  exchange a[i+1] with a[pivot]
  return i+1
```


## 시간복잡도


퀵 정렬의 시간복잡도는 피벗을 어떻게 선택하느냐에 따라 달라집니다. 최악의 경우는 다음과 같이 매번 피벗의 왼쪽 요소가 하나인 경우입니다. 이렇게 되면 아래처럼 높이가 n, 각 층에서 n개의 요소에 대해 정렬을 수행해야 하므로 $O(n^2)$의 복잡도를 가지게 됩니다.


![ex_screenshot](https://i.imgur.com/DcjDotP.png)


가장 좋은 경우는 분할 과정이 균형적이어서, 계산 트리 높이가 n에서 $\log_2{n}$으로 줄어들기 때문입니다. 이렇게되면 높이 $\log_2{n}$, 각 층에서 n개의 요소에 대해 정렬해야 하므로 시간복잡도는 $O(n\log_2{n})$ 입니다.


![ex_screenshot](https://i.imgur.com/FJxdsBC.png)


즉, 퀵 정렬은 정해진 피벗의 위치가 아닌 랜덤하게 선택하는 것이 시간복잡도를 낮추는데 많은 도움이 된다고 합니다.

| 구  분         | 시간복잡도        | 
|----------------|-----------------|
|       최악      |      $O(n^2)$         |  
|      최선        |      $O(n\log_2{n})$          |   
