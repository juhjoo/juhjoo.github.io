---
title: 해시, 해시 테이블(Hash Table)
categories: 
  - Data Structure & Algorithms
last_modified_at: 2020-04-06T13:00:00+09:00
use_math: true
---

## 해시함수(Hash Function)

해시함수는 데이터의 효율적인 관리를 위하여 임의의 길이의 데이터를 고정된 길이의 데이터로 매핑하는 함수입니다. 이때 매핑전 원레 데이터의 값을 키(Ke), 매핑 후 데이터의 값을 해시 값(Hash Value) 또는 해시코드, 매핑하는 과정 자체를 해싱이라고 합니다.  

## 해시테이블(Hash Table)


해시테이블은 효율적인 탐색을 위한 자료구조로 키(Key)를 값(Value)에 대응시킵니다. 키를 값에 대응시킬때 바로 위에서 이야기한 해시함수를 사용하는 것이죠. Hash 테이블을 구현하는 방법은 1) 해시함수로 해시코드를 계산, 2)해시 값 % length로 이루어진 인덱스를 구한 후 키(key)와 값(Value)로 이루어진 리스트를 만들어줍니다.  

이렇게 해시테이블을 만들면 적은 리소스로 많은 데이터를 효율적으로 관리할 수 있는 장점이 있습니다. 색인(index)에 해시값을 사용함으로써 모든 데이터를 탐색하지 않아도 검색, 삽입 그리고 삭제를 수행할 수 있죠. 아래 그림에서도 해시함수에 Sam Doe를 입력하면 14라는 색인(Hash Value)가 생성됩니다. 해시테이블에서 데이터가 저장되는 곳을 버킷(buckets)이라고 합니다. 그리고 기본 연산은 삽입, 삭제, 탐색이 있습니다.  


![ex_screenshot](https://i.imgur.com/risloZD.png)



| 키(key)         | (Hash Value)        | 
|----------------|-----------------|
|       john Smith         |      2          |  
|       Lisa Smith         |      1          |   
|       Sandra Dee         |      14          |   


해시 함수는 키(Key)만 알면 아무리 큰 해시 테이블이라도 크기에 상관 없이 데이터를 바로 찾아낼 수 있습니다. 이진탐색트리가 탐색에 $O(logn)$을 가지는 것에 비해 해시테이블은 탐색에 시간복잡도 $O(1)$를 가집니다. 배열 또한 해시테이블과 동일하게 $O(1)$이지만 메모리를 사전에 할당해야 하기 때문에 효율적이라고 보기 힘들죠.  

키의 전체 개수와 동일한 크기의 버킷을 가진 해시테이블을 Direct-Address table이라고합니다.  


## Direct-address Table

Direct-address Table의 장점은 키 개수와 해시테이블 크기가 동일하기 때문에 해시충돌 문제가 발생하지 않는 다는 것입니다. 해시충돌에 관한 내용은 밑에 이야기 하겠지만 해시함수가 서로 다른 두개의 키에 대해 동일한 해시값을 내는 것을 이야기합니다. 해시 테이블에서 전체 키(U)가 실제 사용하는 키(K)보다 훨씬 많은 경우 사용하지 않는 키를 위해 공간을 확보하는 것이기 때문에 메모리 낭비가 되게 됩니다. 아래처럼 {1, 9, 4, 0, 7, 6}은 굳이 만들 필요가 없는 것이죠.  

![ex_screenshot](https://i.imgur.com/NQSDVQ1.png)


그렇기 때문에 보통 Direct-address Table 보다는 해시테이블 크기가 실제 사용하느 키보다 작은 해시테이블을 사용합니다. 해시테이블 크기를 m, 실제사용하는 키 개수를 n이라고 할때 n/m을 load factor라고 합니다. 이는 해시테이블에서 한 버킷에 평균 몇 개의 키가 매핑되는가를 나타내는 것으로, Direct-address table은 1 이하이며, 1 보다 큰 경우 해시충돌 문제가 발생합니다.  

## 해시충돌

앞서 이야기한 해시 함수는 해시값의 개수보다 보통 많은 키 값을 해시값으로 변환하기 때문에(즉 load factor가 1보다 큰 경우) 해시함수가 서로 다른 두개의 키에 대해서 동일한 해시값을 내는 해시 충돌이 발생하게 됩니다. 아래 그림처럼 'John Smith'와 'Sandra Dee'는 모두 '2'에 매핑되어 해시충돌이 발생하였습니다.  

![ex_screenshot](https://i.imgur.com/W1XpVrc.png)

이와 같은 해시충돌 문제를 해결하기 위해서 다양한 기법들이 있습니다. 두가지 기법을 알아볼 것인데 첫번째는 chaining이고 두번째는 open addressing입니다. chaining은 해시테이블의 크기를 유연하게 만들고, open addressing은 해시테이블 크기는 고정하되 어디에 저장할 것인가에 중점을 둔 구조입니다.  

### Chaining

해시충돌 문제를 해결하기 위한 첫번째 기법중에 하나인 Chaining은 한 버킷당 들어갈 수 있는 값을 제한하지 않는 것입니다. 해당 버킷을 체인처럼 자료구조인 연결리스트(Linked List)로 구현하기 때문입니다. 아래와 그림과 같이 구현됩니다.  

![ex_screenshot](https://i.imgur.com/n6J8ora.png)

데이터를 연결리스트로 저자할 경우 최근에 버킷에 저장된 데이터를 연결리스트 head에 추가합니다. Chaining 방식을 시각화해서 보고 싶다면 <a href="https://www.cs.usfca.edu/~galles/visualization/OpenHash.html">https://www.cs.usfca.edu/~galles/visualization/OpenHash.html</a>를 참고하시면 됩니다.  

#### Chaining 시간복잡도

Chaining 기법의 시간복잡도에 대해서 알아보겠습니다. 먼저 해시테이블 크기가 m이고 사용하는 키 개수가 n, 그리고 해시함수가 키들을 모든 버킷에 균등하게 할당한다면, 버킷 하나당 $n/m=a$개의 키들이 존재할 것입니다. Chaning 시간복잡도를 삽입(Insertion), 탐색(Search), 삭제(Delete) 세가지로 알아보겠습니다.  

먼저 삽입의 시간복잡도는 해시함수를 통해 값을 버킷에 있는 head에 추가하는 데 $O(1)$이 걸립니다. 간단하죠.  

탐색은 두가지로 나누어서 살펴볼 수 있습니다. 해당하는 데이터가 존재하지 않는 경우(unsuccessful search)와 존재하는 경우(successful search)입니다. 해시테이블에 데이터가 존재하지 않는 경우 해시값에 해당하는 모든 요소 $n$개를 탐색해야하고, 끝까지 탐색해도 존재하지 않다는 것을 알수있습니다. unsuccessful search의 시간복잡도는 $O(1+a)$입니다.  

그 다음으로 데이터가 해시테이블에 존재하는 경우(successful search) 중 해당 버킷이 tail에 값이 있는 경우를 살펴보겠습니다. 시간복잡도를 이야기할 때 최악의 경우를 고려해야하기 때문에 이렇게 고려한 것입니다. 버킷 내 $n$개 요소에 반드시 찾고자 하는 값이 존재하기 때문에 $a-1$개만 비교하면 됩니다. 버킷 요소들 평균이 $a$개일 때 successful search는 요소가 $a-1$개인 버킷을 탐색햇는데 찾는 값이 없어서 해당 버킷에 쿼리에 해당하는 데이터를 삽입하여 결과적으로 해당 버킷의 요소수를 $a$개로 만드는 계산량과 동일합니다. 즉 탐색의 시간복잡도는 $O(1+a)$이 됩니다.  

마지막으로 삭제의 시간복잡도도 탐색과 비슷합니다. 우선 해시값을 매핑하고 해당 버킷내에서 데이터가 있는지 탐색해야하기 때문입니다. 하지만 연결리스트로 해시테이블을 구현한 경우 삭제 연산의 계산복잡도는 $O(1)$로 무시할만한 수준입니다.  

| 구  분         | 시간복잡도        | 
|----------------|-----------------|
|       삽입(Insertion)         |      $O(1)$          |  
|       탐색(Search)         |      $O(1+n)$          |   
|       삭제(Delete)         |      $O(1)$          |     



### Open Addressing  


Open Addressing은 한 버킷당 들어갈 수 있는 공간이 하나뿐인 해시테이블입니다. 해시함수로 얻은 주소가 아닌 다른 주소에 데이터를 저장하게 되는 것이죠. 아래 그림에서 키 값 7개(50, 700, 76, 85, 92, 73, 101)를 해시테이블에 저장한다고 생각해봅시다.  

![ex_screenshot](https://i.imgur.com/AAWJngc.png)  

이 그림에서 봐야할 부분은 85입니다. 85를 7로 나눈 나머지는 1이지만 1번 버킷에는 이미 50이 존재합니다. 그럼 그 다음 버킷(2)에 저장해 둡니다. 그 다음 92를 7로 나눈 나머지 역시 1이지만 1번, 2번 버킷 모두 값이 존재하기 때문에 3번 버킷에 저장합니다. 이와 같은 방식이 바로 Open Addressing입니다. Open Addressing 방식을 시각화해서 보고 싶다면 <a href="https://www.cs.usfca.edu/~galles/visualization/ClosedHash.html">https://www.cs.usfca.edu/~galles/visualization/ClosedHash.html</a>를 참고하시면 됩니다.  



### probing


oepn addressing은 해시충돌 문제가 발생할 수 밖에 없고 앞에 본 그림처럼 특정 해시값에 키가 몰리게되면 효율성이 크게 떨어지는 문제가 발생합니다. 이 문제는 probing(탐사) 방식으로 해결할 수 있습니다. 탐사는 해시테이블에서 삽입, 삭제, 탐색을 수행하기 위해 해시테이블 내 새로운 해시값을 찾는 과정입니다. 탐사는 선형 탐사(Linear probing), 제곱 탐사(Quadratic probing) 그리고 이중 해싱(double hashing) 세가지가 있습니다.  

먼저 선형 탐사(Linear probing)은 가장 간단한 방식으로 앞서 살펴본 것과 같이 해당 버킷에 해시값이 있으면 고정 폭(ex)1칸)을 옮겨서 다음 버킷에 해당하는 해시값을 삽입/삭제/삭제합니다. 선형탐사는 특정 해시값 주변 버킷이 모두 채워지는 primary clusting 문제가 있습니다.  

두번째로 제곱 탐사(Quadratic probing)는 고정 폭으로 이동하는 선형 탐사와 달리 그 폭이 제곱수로 늘어난다는 특징이 있습니다. 처음 충돌이 일어나면 $1^2$칸을 옮기고 여기서도 충돌이 발생하면 $2^2$칸, 그 다음에는 $3^2$칸을 이동합니다. 제곱탐사는 여러 개의 서로 다른 키들이 동일한 초기값을 갖는 secondary clusting에 취약합니다.  

![ex_screenshot](https://i.imgur.com/DIcHkOx.png)  

마지막으로 이중해싱(double hashing)은 탐사할 해시값의 규칙성을 없애버리는 것입니다. 2개의 해시함수를 준비해서 하나는 최초의 해시값을 얻을때, 또 다른 하나는 해시 충돌이 일어났을 때 이동 폭을 얻기위해 사용합니다. 이를 이용하면 최초 해시값은 같더라도 이동폭이 달라지기 때문에 최초 해시값이 달라겨 primary, secondary clusting 문제를 완화할 수 있습니다.  



### 시간복잡도


open addressing은 chaining과 달리 해시테이블의 크기가 $m$으로 고정되어 있으므로 $n$개 데이터를 모두 저장하려면 Load Factor $a = n/m$는 1과 같거나 작다고 가정합니다. 즉 해시테이블에 데이터가 모두 저장되어 있지 않다는 의미입니다.  


open addressing 탐색의 계산복잡성은 탐사 횟수에 비례합니다. 따라서 탐색 계산복잡성을 따질 때 핵심은 '탐사 횟수의 기대값'입니다. successful search와 unsuccessful search의 탐사횟수 기대값은 아래와 같습니다.  


$$ \begin{align*} successful\quad search\quad &:\quad \frac { 1 }{ \alpha } \ln { \frac { 1 }{ 1-\alpha } } \ unsuccessful\quad search\quad &:\quad \frac { 1 }{ \alpha } \end{align*} $$


해시테이블에 데이터가 반만 있다고 하면($a = 0.5$) successful search와 unsuccessful search의 기대값은 1.387, 2가 됩니다. 하지만 $a=0.8$이라면 기대값은 8.047, 5로 치솟게 됩니다. 즉 open addressing 탐색은 $a$에 영향을 받게 됩니다. 그렇기 때문에 해시테이블에 데이터가 어느 정도 차게 되면 해시테이블 크기 $m$을 늘리면서 다시 해싱하여 주는 것이 좋습니다. 이 경우는 탐색 뿐만 아니라 삭제, 삽입도 동일합니다.  
